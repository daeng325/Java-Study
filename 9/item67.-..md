# item67. 최적화는 신중히 하라.

최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 더 그렇다. 빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시킬 것인가?

성능 때문에 견고한 구조를 희생하지 말자. **빠른 프로그램보다는 좋은 프로그램을 작성하라.**

좋은 프로그램이지만 원하는 성능이 나오지 않는다면?—> 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것

좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다. 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다. (item15)

{% hint style="info" %}
💡 **설계 단계에서 성능을 반드시 염두에 두어야 한다.**
{% endhint %}

1. **성능을 제한하는 설계를 피하라.**
   1.  컴포넌트끼리, 혹은 외부 시스템과의 소통방식 관련한 설계 요소(API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등)는 완성 후 가장 변경하기가 어렵다.

       —> 위 설계 요소들이 잘못되면 성능을 심각하게 제한할 수 있다.
2. **API를 설계할 때 성능에 주는 영향을 고려하라.**
   1. public 타입을 가변으로 만들면 불필요한 방어적 복사를 수없이 유발할 수 있다. (item50)
      * **item 50. 적시에 방어적 복사본을 만들라. (아래 참고)**
   2. 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 public 클래스는 상위 클래스에 영원히 종속되며 그 성능 제약까지도 물려받게 된다. (item18)
   3. 인터페이스도 있는데 굳이 구현 타입을 사용하는 것은 특정 구현체에 종속되게 한다. (item64)
3. **그렇다고 성능을 위해 API를 왜곡하지는 말라.**
   1. 잘 설계된 API는 성능도 좋은 게 보통이며, 성능 때문에 API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어가 버전업되면 사라질 수 있지만, 왜곡된 API로 인해 영원히 고통받을 것이다. ~~API를 왜곡한다는 게 대체 뭔 말인지 모르겠다만…~~

<details>

<summary><strong>item 50. 적시에 방어적 복사본을 만들라.</strong></summary>

메소드이든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다. 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보라. 확신할 수 없다면 복사본을 만들어 저장해야 한다.

ex) 클라이언트가 건네준 객체를 내부의 Set인스턴스에 저장하거나, Map 인스턴스의 키로 사용한다면? 추후 그 객체가 변경될 경우 객체를 담고 있는 Set 혹은 Map의 불변식이 깨질 것이다.

내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 이유도 마찬가지다. 내 클래스가 불변이든 가변이든, 그 안의 내부 객체가 가변이면 클라이언트에 반환할 때 반드시 심사숙고해야 한다. 안심할 수 없다면 방어적 복사본을 반환해야 한다.

길이가 1 이상인 배열은 무조건 가변임을 잊지 말자. 그러니 내부에서 사용하는 배열은 클라이언트에 반환할 때는 항상 방어적 복사를 수행해야 한다. 혹은 배열의 불변 뷰를 반환하는 대안도 있다. **(item 15)**

통제권을 넘겨받기로 한 메소드나 생성자를 가진 클래스들은 악의적인 클라이언트의 공격에 취약하다. 따라서 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다. 후자의 예로는 래퍼 클래스 패턴(item18)을 들 수 있다. 래퍼 클래스 특성 상 클라이언트는 래퍼에 넘긴 객체에 여전히 접근할 수 있다. 따라서 래퍼의 불변식을 쉽게 파괴할 수 있지만 그 영향을 오직 클라이언트 자신만 받게 된다.



**Q) 그래서 우리의 Dto나 VO들은 다 잘못 설계되어 있는 걸까?**

</details>

신중하게 설계하여 좋은 구조를 갖춘 프로그램을 완성한 다음에야 최적화를 고려해볼 차례가 된다!

그래서 최적화는?

1. 하지 마라.
2. (전문가 한정) 아직 하지 마라.
3. **각각의 최적화 시도 전후로 성능을 측정하라.**
   1. 자바의 경우 프로그래머가 작성하는 코드와 CPU에서 수행하는 명령 사이의 ‘추상화 격차’가 커서 최적화로 인한 성능 변화를 일정하게 예측하기가 그만큼 더 어렵다.
   2. 자바의 성능 모델은 정교하지 않고 구현 시스템, 릴리즈, 프로세서마다의 차이가 있고, 자바 소프트웨어 스택의 모든 요소가 훨씬 복잡해지면서 성능 예측이 더 어려워졌고, 그에 비례해 측정의 중요성도 커졌다.

프로파일링 도구: 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.

* 개별 메소드의 소비 시간과 호출 횟수같은 런타임 정보 제공
* 집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 함

[\[Java\] JMH(Java Microbenchmark Harness) 로 성능 벤치마킹](https://velog.io/@adduci/Java-JMHJava-Microbenchmark-Harness-%EB%A1%9C-%EC%84%B1%EB%8A%A5-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%82%B9)

[Datadog's Continuous Profiling | Datadog](https://www.datadoghq.com/dg/apm/profiler/profiler-general/?utm\_source=advertisement\&utm\_medium=search\&utm\_campaign=dg-google-profiler-apac-bestprofiler\&utm\_keyword=%2Bcode%20%2Bprofiling%20%2Btools\&utm\_matchtype=b\&utm\_campaignid=15424167999\&utm\_adgroupid=130727584735\&gclid=CjwKCAiAleOeBhBdEiwAfgmXfw68pTB7KMQiOlM1SNpRJYFPi0z0ti0-OyRM2A4uVFCDcWlDKVlGyBoCf6IQAvD\_BwE)

[IntelliJ IDEA Profiling Tools](https://lp.jetbrains.com/intellij-idea-profiler/?source=google\&medium=cpc\&campaign=14001267836\&term=java%20performance%20profiling\&content=535405350407\&gclid=CjwKCAiAleOeBhBdEiwAfgmXfx-qM7DZWdukf6nugFCyvVwMvW4pK8JPyzOei3PhBIhvgzenNBG-yxoCQm4QAvD\_BwE)
